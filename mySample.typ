#import "myTemplate.typ": *
#import "@preview/codelst:2.0.0": sourcecode
#import math

#show: project.with(
  anonymous: false,
  title: "比特币:一种点对点的电子货币系统",
  author: "张钧玮",
  school: "计算机学院",
  id: "U202115520",
  mentor: "郑然",
  class: "大数据 专业 2102 班",
  date: (2025, 2, 19),
  abstract_zh:[
    一种完全点对点的电子现金应该能够允许网上交易直接从一方发送给另一方而不需要通过一个金融机构。电子签名提供了一部分的解决方案，但是如果仍然需要一个受信任的第三方来避免双重交易，那就失去了网上交易最主要的优点。我们提供了一个通过点对点网络避免双重交易问题的解决方案。网络通过对交易进行哈希并加入一条持续增长的基于工作量哈希证明的链来给交易加上时间戳，使得一条不能被更改的记录除非重做工作量证明。最长的链不仅为见证事件序列提供证明，还证明它来自最大的CPU算力池。只要CPU算力的主体被不打算联合攻击网络的节点控制，他们就会生成最长的链并把攻击者排除在外。网络本身需要最小的结构，信息尽可能的被广播，节点可以随时离开和重新加入网络，只要接受能够证明他们离开时发生的证据的最长的工作量网络。
  ]
)


= 介绍

互联网上的贸易已经变得几乎完全依赖金融机构作为可靠第三方的服务来处理电子支付。虽然这种系统对大部分交易已经是足够的了，但是它依旧需要忍受基于信任的模型的缺点。完全没有撤销的交易是不完全可能的，因为金融机构不可能避免仲裁纠纷。仲裁的成本提高了交易的花费，限制了最小实际交易规模，削减了小额交易的可能性，以及存在一个更加广泛的花销鉴于失去了的对于不可撤销服务的能力。伴随着撤销服务的可能性，我们需要更多的信任。商家必须担心他们的顾客，麻烦他们提供本来不需要提供的额外信息。一定比例的欺骗被认为是无法避免的，这些成本和不确定性可以通过面对面的使用实体货币来避免，但是不存在一个不需要信任就能在通讯通道上进行交易的机制。

我们需要一个基于加密证明而不是信任的电子交易系统，该系统允许任何有交易意愿的双方直接进行交易而不需要一个可信任的第三方。交易的不可撤销将会保护卖方避免欺骗，而合约程序可以轻易实现来保护买方。在这篇论文中，我们提供一个避免双重支付问题的解决办法，通过使用点对点的分布式时间戳服务器来生成交易的时间顺序的计算证明。这个系统只要诚实节点控制比起合作起来的攻击节点更多的cpu算力就是安全的。
= 交易

我们定义一枚电子货币是一条数字签名链。每个拥有者把货币交给下一个人，通过电子签名上一次交易和下一个拥有者的公钥并把它们添加到币的末尾。收款人可以验证签名来确认链的所有权。
#img(
  image("assets/Snipaste_2025-02-19_19-00-17.png")
)
#indent()这里的问题是买方不能证明拥有者没有对这个币双重支付。一个通常的办法是介绍一个可信任的官方或者铸币厂来检查每笔交易的双重支付。每笔交易以后，货币必须回到铸币厂来发行一枚新币，只有来自铸币厂的货币被认为是没有被双重支付。这个解决方案的问题在于整个金钱系统的命运依赖于运行铸币厂的公司，每笔交易必须通过它们，就像一座银行。

我们需要一种办法为买方知道曾经的拥有者没有签名任何更早的交易。对于我们来说，只有最早的交易是有效的，所以我们不需要关心后面双重支付的尝试。唯一证明一个交易不存在的办法是知道所有的交易。在基于铸币厂的模型中，铸币厂知道所有的交易，决定哪个交易最先抵达。为了不通过一个可信任的第三方来解决这个问题，交易必须被广播，我们需要一个系统为所有参与者对交易的顺序的单一历史提供共识。买方在每笔交易，都需要多数节点认可这笔交易是最先收到的。
= 时间戳服务器

我们提供的方法从时间戳服务器开始，一个时间戳服务器工作通过获取一整个区块的数据项加上时间戳的哈希值并广泛的发布这个哈希，就像在一个报纸的头版上。时间戳证明了数据已经存在在时间上来获得到这个哈希值。每个时间戳包含了上一个时间戳的哈希值，形成一个链条，每个新增的时间戳增强了前一个时间戳的证明。
#image("assets/Snipaste_2025-02-21_20-40-32.png");
= 工作量证明

为了实现一个基于点对点的分布式时间戳服务器，我们会需要使用一个工作量证明系统就好像Adam Back's的哈希链条，而不是报纸的头版头条。这个工作量证明包含遍历获取一个数字，其取哈希时，例如SHA-256算法，这个哈希值开头是一个指定数的0bit位。平均的工作量被所需的0位数而指数增长且可以通过执行一次简单的哈希计算验证。
对于我们的时间戳网络，我们实现了工作量证明通过在区块里增加一个随机数直到一个值被找到以及它给足了区块哈希所需的0bit位数。一旦CPU算力被消耗来满足这个工作量证明，这个区块不能够被更改除非重做工作。随着后续的区块被链接到它上面，改变这个区块的工作将包括改变后面的所有区块。
#image("assets/Snipaste_2025-02-21_20-49-32.png");
#indent()工作量证明同时解决决定谁代表主体的问题。如果主体基于一个ip一个投票权，它会被能够分配大量ip的人破坏。工作量证明是基于一个cpu一票。主体决定被最长的链代表，这个链拥有最大的工作量证明投资池。如果cpu算力的主体由诚实节点掌握，诚实节点就会增长的最快并超越其他竞争链，为了修正一个过去的区块，攻击者就必须重做这个区块和后面所有区块的工作量证明从而超越诚实节点。我们后面会证明随着后续区块被添加一个更慢的攻击者赶上诚实节点的概率将指数级递减。
为了抵消硬件运算速度的增加及平衡不同时期运行节点的利益，工作量证明的难度将由移动平均数法来确定每小时生成区块的平均数。如果区块生成得过快，那么生成的难度就会增加。
= 网络
运行网络的步骤如下所示：
1. 新交易被向所有节点广播
2. 每个节点收集新的交易到一个区块中
3. 每个节点工作以寻找一个困难的工作量证明来证明区块
4. 当一个节点发现一个工作量证明，它向所有节点广播这个区块
5. 节点接收区块只有当所有交易在里面是有效以及还没有被支付的情况下
6. 节点通过使用使用这个区块的哈希值作为上一个哈希值，在链中创建下一个区块的方式表示对这个区块的接受。
节点总是认为最长的链是正确的，致力于延长它。如果两个节点广播了不同版本的下一个区块，一些节点可能先收到其中一个而其他节点先收到另一个。这种情况下，节点基于它们收到的第一个区块工作，但是也保存另一个分支以防止它变为更长的链。当下一个工作量证明被找到间距会被打破，从而使一个分支更长，在另一条分支上工作的节点将会切换到更长的链上。
新交易并不总需要广播给所有的节点。只要它们接触到许多节点，它们就会进入到一个更长的区块中。区块信息广播丢失也是被容忍的。如果一个节点没有接收到一个区块，它会请求它当它接收到下一个区块并意识到它缺失了一个区块。
= 激励

我们约定，每个区块的第一笔交易是一个特殊的交易，它铸造一枚新币给予创造这个区块的人。这增加了支持网络的激励，提供了一种分发货币到流通中的办法，因为没有中央银行来发行货币。新货币按固定量稳定地增加就像金矿矿工消耗资源并增加黄金到流通领域一样。对我们而言，消耗的是  CPU算力和电力。
激励也可以由交易费充当。如果交易的输出值小于其输入值，差价就作为交易费被加到包含此交易的区块的激励中。一旦预定量的货币进入了流通领域，激励将变为只含有交易费，这样可以完全避免通货膨胀。 
激励会有助于鼓励节点保持诚实。如果一个贪心的攻击者有能力聚集比所有诚实节点更多的 CPU 算力，他将面临是以骗回已付款的方式欺诈别人还是使用这些算力生成新货币的抉择。他将发现遵守规则比破坏系统和他自己财产的有效性更有利，因为这些规则准许他获得比所有其他人都多的新货币。
= 回收硬盘空间

一旦一个币的最后一笔交易被足够多的区块覆盖，之前的交易可以被丢弃来节省磁盘空间。为了便于此而不破坏区块的哈希值，交易将会被哈希进默克尔树。只有根节点被纳入区块的哈希值，老区块可以通过剪枝的方式被压缩，树枝内部的哈希不需要被保存。
#image("assets/Snipaste_2025-02-21_21-18-43.png");
#indent()每个不包含交易的区块头大约是 80 bytes。如果每 10 分钟生成一个区块，每年生成80 bytes \* 6 \* 24 \* 365 = 4.2 MB，2008 年在售的典型计算机有 2 GB 内存，并且摩尔定律预测目前每年内存增加 1.2 GB，所以就算区块头一定要存在内存里，存储也不是问题。
= 简化的支付验证

验证交易而不允许一整个网络节点是可以的。一个用户只需要拥有一个最长工作量证明链的区块头的副本，他可以通过向其他网络节点查询以确认他拥有了最长的链，并获取链接交易到给交易打时间戳区块的默克尔分支。虽然他自己不能核实这个交易，但如果交易已经链接到链中的某个位置，就说明一个网络节点已经接受了此交易，而其后追加的区块进一步确认网络已经接受了它。
#image("assets/Snipaste_2025-02-21_21-25-06.png")
同样，只要诚实节点控制着网络，这种简化验证是可靠的，但是如果网络正在被一个攻击者控制，就会变得脆弱。尽管网络节点可以验证它们自己的交易，但是只要攻击者控制着网络，简化方法就可能被欺骗，一种对策是接受其他网络节点发现一个无效区块时发出的警告，提醒用户软件下载整个区块和被警告的交易来验证一致性。频繁交易的公司可能需要运行它们自己的节点来更加独立的安全性和更快的支付确认。
= 合并和分割价值

尽管单独的处理货币是可能的，在一次交易中将其分别的拆成每一分不被允许。为了允许价值被分割和合并，交易将包含多个输入值和输出值。通常会有一个单独的输入来自一个更大的以前的输出或者多个较小输出值的结合，以及最多两个输出值，一个作为支付，一个作为找零，如果有的话，退还给支付发送者。
#image("assets/Snipaste_2025-02-21_21-49-24.png")
注意，当一笔交易依赖多笔交易，以及这些交易又依赖更多交易，永远不需要获取一笔确切交易的历史。
= 隐私

传统银行模型通过限制参与方和可信任第三方对信息的访问来达到一定程度的隐私保护。必须公布所有交易的必要性否决了这个办法，但是隐私仍可在其他地方通过阻断信息流的方式来保护：通过保持公钥匿名。公众可以看到一些人正在支付给另一些人，没有把交易关联到某个人的信息。这和证券交易所发布的信息级别类似，每笔交易的时间和交易量，即行情是公布的，但是不会显示交易的双方是谁。
#image("assets/Snipaste_2025-02-21_21-54-16.png")
作为额外的防火墙，对每笔交易使用新密钥对可以防止他们被关联到一个共同的拥有者。由于多输入值交易存在，有些关联仍不可避免，因为多输入值交易必然暴露其多个输入是属于同一个拥有者的。风险就在于如果一个密钥的拥有者被暴露，关联性将暴露属于同一个拥有者的其他交易。
= 计算
我们考虑一个攻击者试图生成一条比诚实链更快的替代链的情况。即使完成了，这也不会使系统变得可以任意修改，比如凭空创建货币或拿走不属于他的钱。节点将不会接受无效的交易作为支付，而且诚实节点永远不会接受一个包含无效交易的区块。攻击者只可能改变他自己的某笔交易来拿回他不久前已经支出的钱。
诚实链和攻击者链的比赛可表示为二项随机分布。成功事件是诚实节点被延长了一个区块，增加了一点领先，失败事件是攻击者的链延长一个区块，链条链条的差距减1.
攻击者追上诚实链的概率类似于赌徒破产问题。假设一个赌徒又无限的筹码，在一定亏损开始试图回本，我们可以计算他达到盈亏平衡的概率，即攻击者抵达诚实链的概率，如下所示：
#pagebreak()
$
p = "诚实节点找到下一个区块的概率" \
q = "攻击者找到下一个区块的概率" \
q_z = "攻击者从落后z个区块追上诚实链的概率" \
q_z = cases(
  1 "if" p<=q,
  sqrt(q/p)(z) "if" p>q 
)
$
  
假设p>q,概率随着攻击者需要追上的区块数增加而增加。如果他早期没有幸运的追上，他追上的概率会越来越小。

我们现在考虑一个新交易的收款人要等多久才能确保付款人不能再改变这个交易。我们假设作为攻击者的付款人是想让收款人相信他暂时已经付款，然后在一段时间后转换成支付回自己。这时收款人会收到警告，但付款人希望警告已为时已晚。

收款人等到交易被加到区块中且其后追加了  z 个区块。他不知道攻击者确切的进度，但是假设诚实的区块按期望的平均时间生成，攻击者可能的进度将是一个泊松分布，其期望值为：
$ lambda = z q / p $

为了得到攻击者赶上现在的可能性，我们乘算每个进步的泊松密度以及他在那个进度能够赶上诚实链的概率：

$ sum_(k=0)^( oo  ) frac(lambda^k e^(-lambda),k!)  cases(
  (q/p)^(z-k) "if" k <= z \
  1 "if" k > z
) $

变换来避免对无限级数求和

$  
 1-sum_(k=0)^(oo)frac(lambda^k e^(-lambda),k!)(1-(q/p)^(z-k))
$

转换成C代码
#image("assets/Snipaste_2025-02-21_22-42-10.png")

运行得到一些结果，我们可以看到概率随着z指数级下降
#image("assets/Snipaste_2025-02-21_22-43-18.png")
#pagebreak()
= 总结

我们已经给出了一种不依赖信任的电子交易系统。我们从通用的数字签名体系开始，这个体系给出了所有权的强有力的控制，但是它缺少防止双重支付的办法。为了解决这个问题，我们提出了一个是使用工作量记录交易历史的点对点网络，这个网络变得对攻击者不现实去改变如果诚实节点控制了cpu的主体。这个网络因为结构的简洁而强大。节点只需要一点合作就可以工作。它们不需要被验证，因为消息不会路由到任何指定地点只需要被尽可能的传播。节点可以随意离开和加入网络，接受工作量证明链作为它们离开时所发生的证明。它们用cpu算例投票，通过延长有效区块来接受，通过拒绝在不合法的区块上工作表示抵制。任何需要的规则和激励都可以通过共识来得到加强